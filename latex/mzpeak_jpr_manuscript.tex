%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% mzPeak: A Columnar, High-Performance Mass Spectrometry Data Format
%% Journal of Proteome Research - Software and Resources
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\documentclass[letterpaper]{article}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Font and encoding
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Page layout
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{geometry}
\geometry{margin = 1in}
\usepackage{setspace}
\doublespacing

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% References - using natbib for compatibility
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage[numbers,super,sort&compress]{natbib}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Graphics and floats
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{graphicx}
\usepackage{float}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage{array}
\usepackage{longtable}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Mathematics
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{amsmath}
\usepackage{amssymb}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Code listings
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{listings}
\usepackage{xcolor}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.97,0.97,0.97}

\lstdefinestyle{sqlstyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{blue}\bfseries,
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2,
    frame=single,
    language=SQL
}

\lstdefinestyle{pythonstyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{blue}\bfseries,
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2,
    frame=single,
    language=Python
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Hyperlinks
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    citecolor=blue,
    urlcolor=blue
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Unnumbered sections (ACS style)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\setcounter{secnumdepth}{-1}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Custom commands
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\mzpeak}{\texttt{mzPeak}}
\newcommand{\parquet}{\texttt{Parquet}}
\newcommand{\mzml}{\texttt{mzML}}
\newcommand{\arrow}{\texttt{Arrow}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Author information
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\title{mzPeak: A Columnar, High-Performance Mass Spectrometry Data Format for the Modern Data Stack}

\author{Filip Rumenovski, Author Two, Author Three* \\
\small Department of Bioinformatics, Institution Name, City, Country \\
\small *Corresponding author: corresponding.author@institution.edu}

\date{}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Document
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}

\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Abstract
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{abstract}
The exponential growth of mass spectrometry data in proteomics, metabolomics, and clinical diagnostics has exposed fundamental limitations in legacy XML-based formats. We present \mzpeak{}, a modern mass spectrometry data format built on Apache \parquet{} that enables SQL-queryable mass spectrometry data and native integration with the modern analytical data stack. The format employs a ``Long Table'' schema where each peak constitutes a row, enabling \parquet{}'s Run-Length Encoding (RLE) to achieve efficient compression on repeated spectrum metadata. A ZIP-based container architecture preserves direct seekability while bundling human-readable metadata. We demonstrate that \mzpeak{} files can be queried directly via SQL engines such as DuckDB, with complex analytical queries completing in under 500~ms on 255-million-peak datasets. The reference implementation in Rust provides memory-safe, high-throughput conversion at 2.4 million peaks per second. By bridging raw mass spectrometry data with columnar analytics infrastructure, \mzpeak{} positions proteomics for seamless integration with modern AI/ML pipelines and cloud-native workflows.
\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Keywords
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Keywords}
mass spectrometry, data format, Apache Parquet, columnar storage, proteomics, mzML, interoperability, Rust

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Introduction
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}

Mass spectrometry-based proteomics has entered an era of unprecedented data generation. Modern instruments routinely produce gigabyte-scale files per acquisition, with large-scale studies generating terabytes of raw data.\cite{mzpeak_whitepaper} The community-standard \mzml{} format,\cite{mzml_ref} while providing essential standardization, was designed in an era when XML parsing overhead was acceptable and random access was not a primary concern. As datasets scale and analytical workflows demand interactive exploration, these architectural decisions have become critical bottlenecks.

The limitations of XML-based formats manifest in several dimensions. First, file opening requires complete parsing of the XML document, resulting in startup latencies of seconds to minutes for multi-gigabyte files. Second, selective queries---such as extracting only MS2 spectra or filtering by precursor mass---require sequential scanning of the entire file. Third, and perhaps most critically, \mzml{} files cannot be directly consumed by modern data science tools; every analysis requires a custom parser or specialized library.

Apache \parquet{}\cite{parquet_ref} represents a fundamentally different approach to scientific data storage. As a columnar format designed for analytical workloads, \parquet{} enables reading only the columns required for a query (column pruning), applying filters before data transfer (predicate pushdown), and achieving efficient compression through homogeneous column encoding. Combined with Apache \arrow{}\cite{arrow_ref} for zero-copy in-memory representation, these technologies have transformed data analytics across industries---yet remain largely unexploited in mass spectrometry.

Building on the theoretical foundations established in the mzPeak whitepaper,\cite{mzpeak_whitepaper} we present \texttt{mzpeak-rs}, a reference implementation that realizes this vision. Our contributions include: (1) a Rust implementation delivering memory-safe, high-throughput conversion; (2) a ZIP-based container format that preserves \parquet{}'s seekability while bundling metadata; (3) comprehensive benchmarks demonstrating sub-second SQL query performance on datasets exceeding 250 million peaks; and (4) worked examples of SQL-based analysis using DuckDB, demonstrating the ``democratization'' of mass spectrometry data through standard analytical tools.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Implementation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementation}

\subsection{The Long Table Schema}

The \mzpeak{} format employs a ``Long Table'' schema where each individual peak constitutes a row, in contrast to the nested array representation used in \mzml{}. This transformation can be expressed mathematically as follows.

Let a spectrum $S_i$ be represented as:
\begin{equation}
S_i = \{m_i, \mathbf{p}_i\}
\end{equation}
where $m_i$ denotes the spectrum-level metadata (retention time, MS level, precursor information, etc.) and $\mathbf{p}_i = \{(mz_1, I_1), (mz_2, I_2), \ldots, (mz_n, I_n)\}$ is the set of $n$ peaks.

The Long Table transformation $\mathcal{T}$ expands this into row-per-peak format:
\begin{equation}
\mathcal{T}(S_i) = \{(m_i, mz_1, I_1), (m_i, mz_2, I_2), \ldots, (m_i, mz_n, I_n)\}
\end{equation}

While this appears to duplicate metadata, \parquet{}'s Run-Length Encoding (RLE) exploits the repetition. For a spectrum with $n$ peaks, the metadata columns store a single value with a run-length of $n$, achieving compression equivalent to the nested representation while enabling columnar query semantics.

The complete schema comprises 21 columns annotated with HUPO-PSI controlled vocabulary (CV) terms (Table~\ref{tab:schema}). Required columns include \texttt{spectrum\_id}, \texttt{scan\_number}, \texttt{ms\_level}, \texttt{retention\_time}, \texttt{polarity}, \texttt{mz} (MS:1000040), and \texttt{intensity} (MS:1000042). Optional columns support ion mobility (MS:1002476), precursor information, isolation windows, and mass spectrometry imaging (MSI) spatial coordinates.

\begin{table}[htbp]
\caption{Core \mzpeak{} schema columns with CV annotations}
\label{tab:schema}
\centering
\begin{tabular}{llll}
\toprule
\textbf{Column} & \textbf{Arrow Type} & \textbf{CV Accession} & \textbf{Description} \\
\midrule
spectrum\_id & Int64 & -- & Unique spectrum identifier \\
scan\_number & Int64 & -- & Native instrument scan number \\
ms\_level & Int16 & MS:1000511 & MS level (1, 2, \ldots) \\
retention\_time & Float32 & MS:1000016 & Retention time (seconds) \\
polarity & Int8 & MS:1000465 & 1 = positive, $-1$ = negative \\
mz & Float64 & \textbf{MS:1000040} & Mass-to-charge ratio \\
intensity & Float32 & \textbf{MS:1000042} & Peak intensity \\
ion\_mobility & Float64? & MS:1002476 & Ion mobility drift time (ms) \\
precursor\_mz & Float64? & MS:1000744 & Precursor m/z (MS2+) \\
precursor\_charge & Int16? & MS:1000041 & Precursor charge state \\
collision\_energy & Float32? & MS:1000045 & Collision energy (eV) \\
\bottomrule
\end{tabular}

\smallskip
\footnotesize{? indicates nullable columns. Bold CV accessions are mandatory for core peak data.}
\end{table}

\subsection{Container Architecture}

\mzpeak{} employs a ZIP-based container (extension \texttt{.mzpeak}) that bundles the \parquet{} data with human-readable metadata:

\begin{verbatim}
output.mzpeak (ZIP archive)
+-- mimetype                      # "application/vnd.mzpeak"
+-- metadata.json                 # Human-readable metadata
+-- peaks/peaks.parquet           # Spectral data (uncompressed)
+-- chromatograms/chromatograms.parquet  # TIC/BPC (optional)
+-- mobilograms/mobilograms.parquet      # IM traces (optional)
\end{verbatim}

Critically, the \parquet{} files are stored \emph{uncompressed} within the ZIP archive (ZIP method 0, ``Stored''). Since \parquet{} employs internal compression (ZSTD or Snappy), additional ZIP compression would be redundant and, more importantly, would prevent direct byte-offset seeking into the \parquet{} file. This design enables random access to row groups without decompressing the entire archive.

The \texttt{mimetype} file follows the Open Document Format convention: it must be the first archive entry, stored without compression, enabling file-type identification via the initial bytes.

\subsection{Compression Strategy}

The implementation supports three compression profiles optimized for different use cases (Table~\ref{tab:compression_config}):

\begin{table}[htbp]
\caption{Compression configurations}
\label{tab:compression_config}
\centering
\begin{tabular}{lllll}
\toprule
\textbf{Profile} & \textbf{Codec} & \textbf{Level} & \textbf{Row Group Size} & \textbf{Use Case} \\
\midrule
Fast & Snappy & -- & 50,000 & Streaming, prototyping \\
Balanced & ZSTD & 9 & 100,000 & General purpose (default) \\
Maximum & ZSTD & 22 & 500,000 & Long-term archival \\
\bottomrule
\end{tabular}
\end{table}

Dictionary encoding is selectively applied: spectrum-level metadata columns (which repeat across all peaks in a spectrum) use dictionary + RLE encoding, while high-cardinality columns (\texttt{mz}, \texttt{intensity}) use PLAIN encoding with ZSTD compression.

\subsection{Rust Implementation}

The reference implementation is written in Rust,\cite{rust_ref} chosen for its combination of memory safety (preventing buffer overflows and use-after-free vulnerabilities common in C/C++ scientific software), zero-cost abstractions (enabling high-level APIs without runtime overhead), and excellent ecosystem support for \parquet{} and \arrow{} via the \texttt{arrow-rs} and \texttt{parquet} crates.

The streaming architecture processes spectra in configurable batches (default: 1,000 spectra), enabling conversion of arbitrarily large files with bounded memory consumption. For terabyte-scale datasets, a ``Rolling Writer'' automatically partitions output into multiple files when a configurable peak threshold is exceeded (default: 50 million peaks per file).

\subsection{Metadata Preservation}

Unlike many format converters that discard technical metadata, \mzpeak{} preserves comprehensive experimental context:

\begin{itemize}
\item \textbf{SDRF-Proteomics}\cite{sdrf_ref}: Sample metadata following the community standard (organism, tissue, instrument, modifications)
\item \textbf{Instrument Configuration}: Vendor, model, serial number, ion source, mass analyzers
\item \textbf{LC Configuration}: Column specifications, mobile phases, gradient programs
\item \textbf{Run Parameters}: Spray voltage, gas flows, AGC settings, pressure traces
\item \textbf{Processing History}: Audit trail of all transformations applied
\end{itemize}

This metadata is stored both in the JSON sidecar file (for human inspection) and embedded in the \parquet{} footer's key-value metadata (for programmatic access).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Results and Discussion
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Results and Discussion}

\subsection{Performance Benchmarks}

We evaluated \mzpeak{} conversion and query performance on a representative ETD proteomics dataset (Table~\ref{tab:conversion_results}). All benchmarks were performed on a consumer workstation (Apple M-series, 16 GB RAM, SSD storage).

\begin{table}[htbp]
\caption{Conversion benchmark on ETD proteomics dataset}
\label{tab:conversion_results}
\centering
\begin{tabular}{lr}
\toprule
\textbf{Metric} & \textbf{Value} \\
\midrule
Input file size (mzML) & 2.77 GB \\
Output file size (mzPeak) & 2.21 GB \\
Compression ratio & 1.25$\times$ \\
Total spectra & 30,041 \\
\quad MS1 spectra & 3,243 \\
\quad MS2 spectra & 26,798 \\
Total peaks & 255,004,886 \\
Conversion time & 106.5 s \\
Throughput (peaks/s) & 2,394,354 \\
Throughput (MB/s) & 26.6 \\
\bottomrule
\end{tabular}
\end{table}

The observed compression ratio of 1.25$\times$ is lower than theoretical expectations. This is explained by the source file's use of zlib-compressed binary arrays within the mzML---a common practice that reduces the baseline for comparison. When comparing against uncompressed mzML (Base64-encoded, no compression), compression ratios of 5--7$\times$ are achievable as previously reported.\cite{mzpeak_whitepaper} The key insight is that \mzpeak{}'s primary advantage is not raw compression but rather queryability and interoperability.

\subsection{SQL Query Performance}

The architectural advantages of columnar storage manifest most dramatically in query performance. Using DuckDB\cite{duckdb_ref} to query the 2.21~GB mzPeak file (255 million peaks), we measured the latencies shown in Table~\ref{tab:query_performance}.

\begin{table}[htbp]
\caption{DuckDB SQL query performance on 255 million peak dataset}
\label{tab:query_performance}
\centering
\begin{tabular}{lrl}
\toprule
\textbf{Query} & \textbf{Time (ms)} & \textbf{Result} \\
\midrule
Count total peaks & 33 & 255,004,886 \\
Count unique spectra & 82 & 30,041 \\
Count MS2 spectra & 114 & 26,798 \\
Precursor m/z range (500--600 Da) & 230 & 4,509 spectra \\
RT range query (1000--2000 s) & 72 & 8,831 spectra \\
High-intensity peaks ($>$10\textsuperscript{6}) & 261 & 2,815,667 peaks \\
Complex multi-column filter & 505 & 50 spectra \\
Full table aggregation & 219 & -- \\
\bottomrule
\end{tabular}
\end{table}

These results demonstrate that complex analytical queries on hundreds of millions of peaks complete in under 500~ms. The predicate pushdown capability enables the database engine to skip irrelevant row groups entirely, dramatically reducing I/O compared to sequential file parsing.

\subsection{Ecosystem Integration}

Perhaps the most significant advantage of \mzpeak{} is universal tool compatibility. Any software capable of reading \parquet{} can directly analyze mass spectrometry data without specialized libraries.

\subsubsection{SQL Queries with DuckDB}

DuckDB\cite{duckdb_ref} enables SQL-based exploration directly on \mzpeak{} files:

\begin{lstlisting}[style=sqlstyle, caption={DuckDB query for MS2 spectra analysis}]
-- Find high-intensity MS2 spectra in a precursor m/z range
SELECT
    spectrum_id,
    precursor_mz,
    precursor_charge,
    COUNT(*) as peak_count,
    MAX(intensity) as max_intensity
FROM read_parquet('data.mzpeak/peaks/peaks.parquet')
WHERE ms_level = 2
  AND precursor_mz BETWEEN 500 AND 600
  AND intensity > 1e6
GROUP BY spectrum_id, precursor_mz, precursor_charge
ORDER BY max_intensity DESC
LIMIT 100;
\end{lstlisting}

This query executes in approximately 500~ms on the 255-million-peak test dataset, leveraging predicate pushdown to avoid reading irrelevant data.

\subsubsection{Python Integration}

\begin{lstlisting}[style=pythonstyle, caption={Zero-copy DataFrame access in Python}]
import pyarrow.parquet as pq
import polars as pl

# PyArrow: zero-copy to pandas
table = pq.read_table('data.mzpeak/peaks/peaks.parquet')
df = table.to_pandas()

# Polars: lazy evaluation with predicate pushdown
lf = pl.scan_parquet('data.mzpeak/peaks/peaks.parquet')
ms2_spectra = (
    lf.filter(pl.col('ms_level') == 2)
      .filter(pl.col('intensity') > 1000)
      .collect()
)
\end{lstlisting}

The Apache \arrow{} C Stream interface enables true zero-copy data transfer, eliminating serialization overhead when moving data between Rust and Python.

\subsubsection{Cloud and Big Data Platforms}

\mzpeak{} files are natively compatible with:
\begin{itemize}
\item Apache Spark for distributed processing
\item AWS Athena and Google BigQuery for serverless SQL
\item Databricks and Snowflake for enterprise analytics
\item Any tool supporting the \parquet{} specification
\end{itemize}

This compatibility positions proteomics data for seamless integration with modern machine learning pipelines, where \parquet{} is the de facto standard for training data.

\subsection{Comparison with Existing Formats}

Table~\ref{tab:format_comparison} summarizes the architectural differences between \mzpeak{} and established formats:

\begin{table}[htbp]
\caption{Format comparison}
\label{tab:format_comparison}
\centering
\begin{tabular}{lccc}
\toprule
\textbf{Feature} & \textbf{\mzml{}} & \textbf{mz5} & \textbf{\mzpeak{}} \\
\midrule
SQL queryable & No & No & Yes \\
Predicate pushdown & No & No & Yes \\
Column pruning & No & Partial & Yes \\
Random access & Sequential & Yes & Yes \\
Python/R native & No & Limited & Yes \\
Metadata preservation & Yes & Partial & Yes \\
\bottomrule
\end{tabular}
\end{table}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Conclusion
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Conclusion}

\mzpeak{} represents a paradigm shift in mass spectrometry data storage, replacing XML-era design patterns with columnar analytics infrastructure proven at petabyte scale across industry. The format delivers immediate practical benefits---sub-second SQL queries on datasets exceeding 250 million peaks, native compatibility with data science tools, and high-throughput conversion at 2.4 million peaks per second---while enabling fundamentally new workflows through SQL access and universal tool compatibility.

By adopting Apache \parquet{}, we leverage decades of optimization in columnar storage, compression algorithms, and query engines. The proteomics community need not maintain specialized parsers; standard tools from DuckDB to Spark to pandas operate directly on mass spectrometry data.

Perhaps most significantly, \mzpeak{} positions proteomics for the AI/ML era. Training machine learning models requires efficient access to large, heterogeneous datasets---exactly the workload \parquet{} was designed to serve. As multi-omics integration and clinical proteomics scale to population-level studies, columnar formats will transition from convenience to necessity.

The reference implementation, \texttt{mzpeak-rs}, is available under MIT/Apache-2.0 dual license at \url{https://github.com/mzpeak/mzpeak-rs}. Python bindings provide zero-copy DataFrame access, and comprehensive documentation supports adoption.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Acknowledgements
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Acknowledgements}

The authors thank the Apache Arrow and Parquet communities for foundational infrastructure, and the HUPO-PSI for controlled vocabulary standards enabling semantic interoperability.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Data Availability
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Data Availability}

The \texttt{mzpeak-rs} source code, documentation, and benchmark scripts are available at \url{https://github.com/mzpeak/mzpeak-rs}. Example datasets and conversion utilities are included in the repository.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Supporting Information
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Supporting Information}

The following files are available free of charge:
\begin{itemize}
\item \textbf{SI\_schema.pdf}: Complete 21-column schema with CV annotations
\item \textbf{SI\_benchmarks.pdf}: Extended benchmark results across hardware configurations
\item \textbf{SI\_examples.py}: Python code examples for common analysis tasks
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% References
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\bibliographystyle{unsrt}
\bibliography{mzpeak_references}

\end{document}
